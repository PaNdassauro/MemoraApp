"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useUpload.ts":
/*!********************************!*\
  !*** ./src/hooks/useUpload.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useUpload: () => (/* binding */ useUpload)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _useImageProcessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useImageProcessor */ \"(app-pages-browser)/./src/hooks/useImageProcessor.ts\");\n\n\n\nfunction useUpload() {\n    const [uploads, setUploads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isUploading, setIsUploading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const { processImageWithAI } = (0,_useImageProcessor__WEBPACK_IMPORTED_MODULE_2__.useImageProcessor)();\n    const updateUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useUpload.useCallback[updateUpload]\": (file, updates)=>{\n            setUploads({\n                \"useUpload.useCallback[updateUpload]\": (prev)=>prev.map({\n                        \"useUpload.useCallback[updateUpload]\": (u)=>u.file === file ? {\n                                ...u,\n                                ...updates\n                            } : u\n                    }[\"useUpload.useCallback[updateUpload]\"])\n            }[\"useUpload.useCallback[updateUpload]\"]);\n        }\n    }[\"useUpload.useCallback[updateUpload]\"], []);\n    const uploadFiles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useUpload.useCallback[uploadFiles]\": async function(files) {\n            let folderId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n            if (files.length === 0) return;\n            setIsUploading(true);\n            // Initialize upload states\n            const initialUploads = files.map({\n                \"useUpload.useCallback[uploadFiles].initialUploads\": (file)=>({\n                        file,\n                        progress: 0,\n                        status: 'pending'\n                    })\n            }[\"useUpload.useCallback[uploadFiles].initialUploads\"]);\n            setUploads({\n                \"useUpload.useCallback[uploadFiles]\": (prev)=>[\n                        ...prev,\n                        ...initialUploads\n                    ]\n            }[\"useUpload.useCallback[uploadFiles]\"]);\n            // Process each file\n            for (const file of files){\n                try {\n                    // Update status to uploading\n                    updateUpload(file, {\n                        status: 'uploading',\n                        progress: 10\n                    });\n                    // Generate unique file path\n                    const fileExt = file.name.split('.').pop();\n                    const fileName = \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(7), \".\").concat(fileExt);\n                    const filePath = \"uploads/\".concat(fileName);\n                    // Upload to Supabase Storage\n                    const { error: uploadError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.storage.from(_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.PHOTOS_BUCKET).upload(filePath, file, {\n                        cacheControl: '3600',\n                        upsert: false\n                    });\n                    if (uploadError) {\n                        throw new Error(uploadError.message);\n                    }\n                    updateUpload(file, {\n                        progress: 50\n                    });\n                    // Get Public URL (consistent with portfolio_media)\n                    const { data: { publicUrl } } = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.storage.from(_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.PHOTOS_BUCKET).getPublicUrl(filePath);\n                    const storageUrl = publicUrl;\n                    // Update status to processing (AI)\n                    updateUpload(file, {\n                        status: 'processing',\n                        progress: 60\n                    });\n                    // Process with AI (mock for now)\n                    const metadata = await processImageWithAI(storageUrl);\n                    updateUpload(file, {\n                        progress: 80\n                    });\n                    // Save to portfolio_media (Unified table)\n                    const { error: dbError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('portfolio_media').insert({\n                        file_url: storageUrl,\n                        moment: (metadata === null || metadata === void 0 ? void 0 : metadata.category) || 'Outro',\n                        tags: (metadata === null || metadata === void 0 ? void 0 : metadata.tags) || [],\n                        description: (metadata === null || metadata === void 0 ? void 0 : metadata.description) || '',\n                        folder_id: folderId,\n                        type: 'Foto',\n                        usage_override: 'Liberado',\n                        publication_status: 'NÃ£o usado',\n                        is_hero: false\n                    });\n                    if (dbError) {\n                        console.error('Database error:', dbError.message);\n                        throw new Error(dbError.message);\n                    }\n                    // Complete\n                    updateUpload(file, {\n                        status: 'complete',\n                        progress: 100\n                    });\n                } catch (err) {\n                    const errorMessage = err instanceof Error ? err.message : 'Erro no upload';\n                    updateUpload(file, {\n                        status: 'error',\n                        error: errorMessage\n                    });\n                    console.error(\"Upload failed for \".concat(file.name, \":\"), err);\n                }\n            }\n            setIsUploading(false);\n        }\n    }[\"useUpload.useCallback[uploadFiles]\"], [\n        processImageWithAI,\n        updateUpload\n    ]);\n    const clearCompleted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useUpload.useCallback[clearCompleted]\": ()=>{\n            setUploads({\n                \"useUpload.useCallback[clearCompleted]\": (prev)=>prev.filter({\n                        \"useUpload.useCallback[clearCompleted]\": (u)=>u.status !== 'complete'\n                    }[\"useUpload.useCallback[clearCompleted]\"])\n            }[\"useUpload.useCallback[clearCompleted]\"]);\n        }\n    }[\"useUpload.useCallback[clearCompleted]\"], []);\n    return {\n        uploadFiles,\n        uploads,\n        isUploading,\n        clearCompleted\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VVcGxvYWQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDWTtBQUNGO0FBVWpELFNBQVNLO0lBQ1osTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdQLCtDQUFRQSxDQUFtQixFQUFFO0lBQzNELE1BQU0sQ0FBQ1EsYUFBYUMsZUFBZSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLEVBQUVVLGtCQUFrQixFQUFFLEdBQUdOLHFFQUFpQkE7SUFFaEQsTUFBTU8sZUFBZVYsa0RBQVdBOytDQUFDLENBQUNXLE1BQVlDO1lBQzFDTjt1REFBV08sQ0FBQUEsT0FDUEEsS0FBS0MsR0FBRzsrREFBQ0MsQ0FBQUEsSUFBS0EsRUFBRUosSUFBSSxLQUFLQSxPQUFPO2dDQUFFLEdBQUdJLENBQUM7Z0NBQUUsR0FBR0gsT0FBTzs0QkFBQyxJQUFJRzs7O1FBRS9EOzhDQUFHLEVBQUU7SUFFTCxNQUFNQyxjQUFjaEIsa0RBQVdBOzhDQUFDLGVBQU9pQjtnQkFBZUMsNEVBQTBCO1lBQzVFLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHO1lBRXhCWCxlQUFlO1lBRWYsMkJBQTJCO1lBQzNCLE1BQU1ZLGlCQUFtQ0gsTUFBTUgsR0FBRztxRUFBQ0gsQ0FBQUEsT0FBUzt3QkFDeERBO3dCQUNBVSxVQUFVO3dCQUNWQyxRQUFRO29CQUNaOztZQUNBaEI7c0RBQVdPLENBQUFBLE9BQVE7MkJBQUlBOzJCQUFTTztxQkFBZTs7WUFFL0Msb0JBQW9CO1lBQ3BCLEtBQUssTUFBTVQsUUFBUU0sTUFBTztnQkFDdEIsSUFBSTtvQkFDQSw2QkFBNkI7b0JBQzdCUCxhQUFhQyxNQUFNO3dCQUFFVyxRQUFRO3dCQUFhRCxVQUFVO29CQUFHO29CQUV2RCw0QkFBNEI7b0JBQzVCLE1BQU1FLFVBQVVaLEtBQUthLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEtBQUtDLEdBQUc7b0JBQ3hDLE1BQU1DLFdBQVcsR0FBaUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUE4Q1AsT0FBM0NLLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxJQUFHLEtBQVcsT0FBUlY7b0JBQzdFLE1BQU1XLFdBQVcsV0FBb0IsT0FBVFA7b0JBRTVCLDZCQUE2QjtvQkFDN0IsTUFBTSxFQUFFUSxPQUFPQyxXQUFXLEVBQUUsR0FBRyxNQUFNbkMsbURBQVFBLENBQUNvQyxPQUFPLENBQ2hEQyxJQUFJLENBQUNwQyx3REFBYUEsRUFDbEJxQyxNQUFNLENBQUNMLFVBQVV2QixNQUFNO3dCQUNwQjZCLGNBQWM7d0JBQ2RDLFFBQVE7b0JBQ1o7b0JBRUosSUFBSUwsYUFBYTt3QkFDYixNQUFNLElBQUlNLE1BQU1OLFlBQVlPLE9BQU87b0JBQ3ZDO29CQUVBakMsYUFBYUMsTUFBTTt3QkFBRVUsVUFBVTtvQkFBRztvQkFFbEMsbURBQW1EO29CQUNuRCxNQUFNLEVBQUV1QixNQUFNLEVBQUVDLFNBQVMsRUFBRSxFQUFFLEdBQUc1QyxtREFBUUEsQ0FBQ29DLE9BQU8sQ0FDM0NDLElBQUksQ0FBQ3BDLHdEQUFhQSxFQUNsQjRDLFlBQVksQ0FBQ1o7b0JBRWxCLE1BQU1hLGFBQWFGO29CQUVuQixtQ0FBbUM7b0JBQ25DbkMsYUFBYUMsTUFBTTt3QkFBRVcsUUFBUTt3QkFBY0QsVUFBVTtvQkFBRztvQkFFeEQsaUNBQWlDO29CQUNqQyxNQUFNMkIsV0FBVyxNQUFNdkMsbUJBQW1Cc0M7b0JBRTFDckMsYUFBYUMsTUFBTTt3QkFBRVUsVUFBVTtvQkFBRztvQkFFbEMsMENBQTBDO29CQUMxQyxNQUFNLEVBQUVjLE9BQU9jLE9BQU8sRUFBRSxHQUFHLE1BQU1oRCxtREFBUUEsQ0FDcENxQyxJQUFJLENBQUMsbUJBQ0xZLE1BQU0sQ0FBQzt3QkFDSkMsVUFBVUo7d0JBQ1ZLLFFBQVFKLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVUssUUFBUSxLQUFJO3dCQUM5QkMsTUFBTU4sQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVTSxJQUFJLEtBQUksRUFBRTt3QkFDMUJDLGFBQWFQLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVU8sV0FBVyxLQUFJO3dCQUN0Q0MsV0FBV3RDO3dCQUNYdUMsTUFBTTt3QkFDTkMsZ0JBQWdCO3dCQUNoQkMsb0JBQW9CO3dCQUNwQkMsU0FBUztvQkFDYjtvQkFFSixJQUFJWCxTQUFTO3dCQUNUWSxRQUFRMUIsS0FBSyxDQUFDLG1CQUFtQmMsUUFBUU4sT0FBTzt3QkFDaEQsTUFBTSxJQUFJRCxNQUFNTyxRQUFRTixPQUFPO29CQUNuQztvQkFFQSxXQUFXO29CQUNYakMsYUFBYUMsTUFBTTt3QkFBRVcsUUFBUTt3QkFBWUQsVUFBVTtvQkFBSTtnQkFFM0QsRUFBRSxPQUFPeUMsS0FBSztvQkFDVixNQUFNQyxlQUFlRCxlQUFlcEIsUUFBUW9CLElBQUluQixPQUFPLEdBQUc7b0JBQzFEakMsYUFBYUMsTUFBTTt3QkFBRVcsUUFBUTt3QkFBU2EsT0FBTzRCO29CQUFhO29CQUMxREYsUUFBUTFCLEtBQUssQ0FBQyxxQkFBK0IsT0FBVnhCLEtBQUthLElBQUksRUFBQyxNQUFJc0M7Z0JBQ3JEO1lBQ0o7WUFFQXRELGVBQWU7UUFDbkI7NkNBQUc7UUFBQ0M7UUFBb0JDO0tBQWE7SUFFckMsTUFBTXNELGlCQUFpQmhFLGtEQUFXQTtpREFBQztZQUMvQk07eURBQVdPLENBQUFBLE9BQVFBLEtBQUtvRCxNQUFNO2lFQUFDbEQsQ0FBQUEsSUFBS0EsRUFBRU8sTUFBTSxLQUFLOzs7UUFDckQ7Z0RBQUcsRUFBRTtJQUVMLE9BQU87UUFDSE47UUFDQVg7UUFDQUU7UUFDQXlEO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL2hvbWUvcGFuZGFzc2F1cm8vTWVtb3JhQXBwL3NyYy9ob29rcy91c2VVcGxvYWQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3VwYWJhc2UsIFBIT1RPU19CVUNLRVQgfSBmcm9tICcuLi9saWIvc3VwYWJhc2UnO1xuaW1wb3J0IHsgdXNlSW1hZ2VQcm9jZXNzb3IgfSBmcm9tICcuL3VzZUltYWdlUHJvY2Vzc29yJztcbmltcG9ydCB0eXBlIHsgVXBsb2FkUHJvZ3Jlc3MgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBVc2VVcGxvYWRSZXR1cm4ge1xuICAgIHVwbG9hZEZpbGVzOiAoZmlsZXM6IEZpbGVbXSwgZm9sZGVySWQ/OiBzdHJpbmcgfCBudWxsKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIHVwbG9hZHM6IFVwbG9hZFByb2dyZXNzW107XG4gICAgaXNVcGxvYWRpbmc6IGJvb2xlYW47XG4gICAgY2xlYXJDb21wbGV0ZWQ6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcGxvYWQoKTogVXNlVXBsb2FkUmV0dXJuIHtcbiAgICBjb25zdCBbdXBsb2Fkcywgc2V0VXBsb2Fkc10gPSB1c2VTdGF0ZTxVcGxvYWRQcm9ncmVzc1tdPihbXSk7XG4gICAgY29uc3QgW2lzVXBsb2FkaW5nLCBzZXRJc1VwbG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyBwcm9jZXNzSW1hZ2VXaXRoQUkgfSA9IHVzZUltYWdlUHJvY2Vzc29yKCk7XG5cbiAgICBjb25zdCB1cGRhdGVVcGxvYWQgPSB1c2VDYWxsYmFjaygoZmlsZTogRmlsZSwgdXBkYXRlczogUGFydGlhbDxVcGxvYWRQcm9ncmVzcz4pID0+IHtcbiAgICAgICAgc2V0VXBsb2FkcyhwcmV2ID0+XG4gICAgICAgICAgICBwcmV2Lm1hcCh1ID0+IHUuZmlsZSA9PT0gZmlsZSA/IHsgLi4udSwgLi4udXBkYXRlcyB9IDogdSlcbiAgICAgICAgKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1cGxvYWRGaWxlcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChmaWxlczogRmlsZVtdLCBmb2xkZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGwpID0+IHtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHNldElzVXBsb2FkaW5nKHRydWUpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdXBsb2FkIHN0YXRlc1xuICAgICAgICBjb25zdCBpbml0aWFsVXBsb2FkczogVXBsb2FkUHJvZ3Jlc3NbXSA9IGZpbGVzLm1hcChmaWxlID0+ICh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJ1xuICAgICAgICB9KSk7XG4gICAgICAgIHNldFVwbG9hZHMocHJldiA9PiBbLi4ucHJldiwgLi4uaW5pdGlhbFVwbG9hZHNdKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggZmlsZVxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyB0byB1cGxvYWRpbmdcbiAgICAgICAgICAgICAgICB1cGRhdGVVcGxvYWQoZmlsZSwgeyBzdGF0dXM6ICd1cGxvYWRpbmcnLCBwcm9ncmVzczogMTAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUV4dCA9IGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyl9LiR7ZmlsZUV4dH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYHVwbG9hZHMvJHtmaWxlTmFtZX1gO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBsb2FkIHRvIFN1cGFiYXNlIFN0b3JhZ2VcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiB1cGxvYWRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbShQSE9UT1NfQlVDS0VUKVxuICAgICAgICAgICAgICAgICAgICAudXBsb2FkKGZpbGVQYXRoLCBmaWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVwbG9hZEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZChmaWxlLCB7IHByb2dyZXNzOiA1MCB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBQdWJsaWMgVVJMIChjb25zaXN0ZW50IHdpdGggcG9ydGZvbGlvX21lZGlhKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBwdWJsaWNVcmwgfSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbShQSE9UT1NfQlVDS0VUKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0UHVibGljVXJsKGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VVcmwgPSBwdWJsaWNVcmw7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIHRvIHByb2Nlc3NpbmcgKEFJKVxuICAgICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZChmaWxlLCB7IHN0YXR1czogJ3Byb2Nlc3NpbmcnLCBwcm9ncmVzczogNjAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHdpdGggQUkgKG1vY2sgZm9yIG5vdylcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHByb2Nlc3NJbWFnZVdpdGhBSShzdG9yYWdlVXJsKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZChmaWxlLCB7IHByb2dyZXNzOiA4MCB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdG8gcG9ydGZvbGlvX21lZGlhIChVbmlmaWVkIHRhYmxlKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IGRiRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdwb3J0Zm9saW9fbWVkaWEnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfdXJsOiBzdG9yYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50OiBtZXRhZGF0YT8uY2F0ZWdvcnkgfHwgJ091dHJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IG1ldGFkYXRhPy50YWdzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1ldGFkYXRhPy5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRlcl9pZDogZm9sZGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRm90bycsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZV9vdmVycmlkZTogJ0xpYmVyYWRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uX3N0YXR1czogJ07Do28gdXNhZG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNfaGVybzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBlcnJvcjonLCBkYkVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGJFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZVxuICAgICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZChmaWxlLCB7IHN0YXR1czogJ2NvbXBsZXRlJywgcHJvZ3Jlc3M6IDEwMCB9KTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvIG5vIHVwbG9hZCc7XG4gICAgICAgICAgICAgICAgdXBkYXRlVXBsb2FkKGZpbGUsIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVwbG9hZCBmYWlsZWQgZm9yICR7ZmlsZS5uYW1lfTpgLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNVcGxvYWRpbmcoZmFsc2UpO1xuICAgIH0sIFtwcm9jZXNzSW1hZ2VXaXRoQUksIHVwZGF0ZVVwbG9hZF0pO1xuXG4gICAgY29uc3QgY2xlYXJDb21wbGV0ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFVwbG9hZHMocHJldiA9PiBwcmV2LmZpbHRlcih1ID0+IHUuc3RhdHVzICE9PSAnY29tcGxldGUnKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBsb2FkRmlsZXMsXG4gICAgICAgIHVwbG9hZHMsXG4gICAgICAgIGlzVXBsb2FkaW5nLFxuICAgICAgICBjbGVhckNvbXBsZXRlZFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInN1cGFiYXNlIiwiUEhPVE9TX0JVQ0tFVCIsInVzZUltYWdlUHJvY2Vzc29yIiwidXNlVXBsb2FkIiwidXBsb2FkcyIsInNldFVwbG9hZHMiLCJpc1VwbG9hZGluZyIsInNldElzVXBsb2FkaW5nIiwicHJvY2Vzc0ltYWdlV2l0aEFJIiwidXBkYXRlVXBsb2FkIiwiZmlsZSIsInVwZGF0ZXMiLCJwcmV2IiwibWFwIiwidSIsInVwbG9hZEZpbGVzIiwiZmlsZXMiLCJmb2xkZXJJZCIsImxlbmd0aCIsImluaXRpYWxVcGxvYWRzIiwicHJvZ3Jlc3MiLCJzdGF0dXMiLCJmaWxlRXh0IiwibmFtZSIsInNwbGl0IiwicG9wIiwiZmlsZU5hbWUiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZmlsZVBhdGgiLCJlcnJvciIsInVwbG9hZEVycm9yIiwic3RvcmFnZSIsImZyb20iLCJ1cGxvYWQiLCJjYWNoZUNvbnRyb2wiLCJ1cHNlcnQiLCJFcnJvciIsIm1lc3NhZ2UiLCJkYXRhIiwicHVibGljVXJsIiwiZ2V0UHVibGljVXJsIiwic3RvcmFnZVVybCIsIm1ldGFkYXRhIiwiZGJFcnJvciIsImluc2VydCIsImZpbGVfdXJsIiwibW9tZW50IiwiY2F0ZWdvcnkiLCJ0YWdzIiwiZGVzY3JpcHRpb24iLCJmb2xkZXJfaWQiLCJ0eXBlIiwidXNhZ2Vfb3ZlcnJpZGUiLCJwdWJsaWNhdGlvbl9zdGF0dXMiLCJpc19oZXJvIiwiY29uc29sZSIsImVyciIsImVycm9yTWVzc2FnZSIsImNsZWFyQ29tcGxldGVkIiwiZmlsdGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useUpload.ts\n"));

/***/ })

});